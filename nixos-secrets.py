#!/usr/bin/env python3

import argparse
import getpass
import os
import sys
import tempfile
from typing import BinaryIO

import gnupg

EXCLUDE_FILES = [
    'nixos-secrets.py',
    'default.nix'
]

gpg = gnupg.GPG()

secrets_dir: str = os.path.dirname(os.path.abspath(__file__))


def get_umask():
    old_umask = os.umask(0)
    os.umask(old_umask)
    return old_umask


def is_encrypted(file: BinaryIO) -> bool:
    """
    Try to detect a PGP encrypted file that was generated by this script.
    Checks the first packet type and encryption algorithm.
    :return: True if the file seems to be an encrypted secret
    """
    header = file.read(7)

    try:
        # Check that first bit is 1
        if header[0] & 0x80 == 0:
            return False

        if header[0] & 0x40 == 0:
            # Old packet format

            # Check that packet tag is 3: "Symmetric-Key Encrypted Session Key Packet"
            if (header[0] & 0x3C) >> 2 != 3:
                return False

            length_type = header[0] & 0x3
            if length_type == 0:
                body_offset = 2
            elif length_type == 1:
                body_offset = 3
            elif length_type == 2:
                body_offset = 5
            else:  # if length_type == 3:
                # Indeterminate length
                body_offset = 1

            # Version 4 (no other version exists)
            if header[body_offset] != 0x4:
                return False

            # AES256 encrypted
            if header[body_offset + 1] != 0x9:
                return False

        else:
            # New packet format

            # Check that packet tag is 3: "Symmetric-Key Encrypted Session Key Packet"
            if header[0] & 0x3F != 3:
                return False

            # More checks could be done, but GPG doesn't even seem to generate this format

    except IndexError:
        # Packet was too short
        return False
    return True


def all_secrets():
    for dir_path, dir_names, file_names in os.walk(secrets_dir):
        for file_name in file_names:
            file_path = os.path.join(dir_path, file_name)
            if os.path.relpath(file_path, secrets_dir) in EXCLUDE_FILES:
                continue
            yield file_path


def read_key(args) -> str:
    if args.key_file is not None:
        with open(args.key_file, mode='r') as key_file:
            key = key_file.read()
    elif args.key_fd is not None:
        with os.fdopen(args.key_fd, mode='r') as key_file:
            key = key_file.read()
    else:
        key = getpass.getpass("Password: ")
    # Strip trailing newline
    return key.rstrip('\n')


def encrypt(file_path: str, key: str) -> None:
    file_dir, file_name = os.path.split(file_path)
    with open(file_path, 'rb') as file, tempfile.NamedTemporaryFile(dir=file_dir, prefix=file_name,
                                                                    delete=False) as enc_temp:
        result = gpg.encrypt_file(file, output=enc_temp.name, symmetric='AES256', passphrase=key, recipients=None,
                                  armor=False)
        if result.ok:
            os.fchmod(enc_temp.file.fileno(), 0o666 & ~get_umask())
    if result.ok:
        os.replace(enc_temp.name, file_path)
    else:
        os.remove(enc_temp.name)
        raise ChildProcessError(result.status)


def decrypt(file_path: str, key: str) -> None:
    file_dir, file_name = os.path.split(file_path)
    with open(file_path, 'rb') as file, tempfile.NamedTemporaryFile(dir=file_dir, prefix=file_name,
                                                                    delete=False) as dec_temp:
        result = gpg.decrypt_file(file, output=dec_temp.name, passphrase=key)
        if result.ok:
            os.fchmod(dec_temp.file.fileno(), 0o666 & ~get_umask())
    if result.ok:
        os.replace(dec_temp.name, file_path)
    else:
        os.remove(dec_temp.name)
        raise ChildProcessError(result.status)


def encrypt_command(args) -> None:
    key = read_key(args)

    for file_path in args.files:
        with open(file_path, mode='rb') as file:
            if is_encrypted(file):
                print("Warning: \"{}\" is already encrypted, skipping".format(file_path), file=sys.stderr)
                continue

        try:
            encrypt(file_path, key)
        except ChildProcessError as e:
            print("Error: {}".format(e), file=sys.stderr)
            sys.exit(2)


def decrypt_command(args) -> None:
    key = read_key(args)

    for file_path in args.files:
        try:
            decrypt(file_path, key)
        except ChildProcessError as e:
            print("Error: {}".format(e), file=sys.stderr)


def check_command(args) -> None:
    all_encrypted = True
    for file_path in all_secrets():
        with open(file_path, mode='rb') as file:
            if not is_encrypted(file):
                print("\"{}\" is not encrypted".format(file_path))
                all_encrypted = False
    if all_encrypted:
        print("All secrets are encrypted")
    else:
        sys.exit(2)


def check_fd(value: str) -> int:
    try:
        fd = int(value)
        if fd < 0:
            raise ValueError()
    except ValueError:
        raise argparse.ArgumentTypeError("file descriptor must be an integer >= 0")
    return fd


def main() -> None:
    parser = argparse.ArgumentParser(description="Manage NixOS secret files")
    key_group = parser.add_mutually_exclusive_group()
    key_group.add_argument('--key-file', help="file containing the secret key")
    key_group.add_argument('--key-fd', type=check_fd, help="file descriptor to read the key from")
    subparsers = parser.add_subparsers()

    encrypt_parser = subparsers.add_parser('encrypt', help="encrypt secrets")
    encrypt_parser.add_argument('files', nargs='+', help="files to encrypt")
    encrypt_parser.set_defaults(func=encrypt_command)

    decrypt_parser = subparsers.add_parser('decrypt', help="decrypt secrets")
    decrypt_parser.add_argument('files', nargs='+', help='files to decrypt')
    decrypt_parser.set_defaults(func=decrypt_command)

    check_parser = subparsers.add_parser('check', help="check that all secrets are encrypted")
    check_parser.set_defaults(func=check_command)

    args = parser.parse_args()
    if 'func' in args:
        args.func(args)
    else:
        parser.print_usage()


if __name__ == '__main__':
    main()
